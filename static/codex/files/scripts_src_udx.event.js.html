<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>scripts/src/udx.event.js - usabilitydynamics/lib-utility</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="usabilitydynamics/lib-utility"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Utility.html">Utility</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/ud.html">ud</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: scripts/src/udx.event.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * UD Event
 *
 * Event Emitter handler.
 *
 * @original https://github.com/hij1nx/EventEmitter2/
 * @version 0.4
 * @module ud
 * @submodule event 
 * @author team@UD
 */

  var ud = ( typeof ud === &#x27;object&#x27; ) ? ud : {};

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;
  };

  function init() {
    this._events = {};

    if (this._conf) {
      configure.call(this, this._conf);
    }

  }

  function configure(conf) {
    
    this._conf = conf || ud.event.prototype.defaults;
    
    console.log( &#x27;configure&#x27;, this._conf );
    if (this._conf.wildcard) {
      this.listenerTree = {};
    }

  }

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength &amp;&amp; tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === &#x27;function&#x27;) {
        handlers &amp;&amp; handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf &lt; len; leaf++) {
          handlers &amp;&amp; handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === &#x27;*&#x27; || currentType === &#x27;**&#x27;) || tree[currentType]) {
      //
      // If the event emitted is &#x27;*&#x27; at this part
      // or there is a concrete match at this patch
      //
      if (currentType === &#x27;*&#x27;) {
        for (branch in tree) {
          if (branch !== &#x27;_listeners&#x27; &amp;&amp; tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === &#x27;**&#x27;) {
        endReached = (i+1 === typeLength || (i+2 === typeLength &amp;&amp; nextType === &#x27;*&#x27;));
        if(endReached &amp;&amp; tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== &#x27;_listeners&#x27; &amp;&amp; tree.hasOwnProperty(branch)) {
            if(branch === &#x27;*&#x27; || branch === &#x27;**&#x27;) {
              if(tree[branch]._listeners &amp;&amp; !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree[&#x27;*&#x27;];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree[&#x27;**&#x27;];
    if(xxTree) {
      if(i &lt; typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a &#x27;**&#x27;, it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== &#x27;_listeners&#x27; &amp;&amp; xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { &#x27;**&#x27;: isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a &#x27;**&#x27;
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree[&#x27;*&#x27;] &amp;&amp; xxTree[&#x27;*&#x27;]._listeners) {
        searchListenerTree(handlers, type, xxTree[&#x27;*&#x27;], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === &#x27;string&#x27; ? type.split(this._conf.delimiter) : type.slice();

    //
    // Looks for two consecutive &#x27;**&#x27;, if so, don&#x27;t add the event at all.
    //
    for(var i = 0, len = type.length; i+1 &lt; len; i++) {
      if(type[i] === &#x27;**&#x27; &amp;&amp; type[i+1] === &#x27;**&#x27;) {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }

        else if(typeof tree._listeners === &#x27;function&#x27;) {
          tree._listeners = [tree._listeners, listener];
        }

        else if (isArray(tree._listeners)) {

          tree._listeners.push(listener);

          if (!tree._listeners.warned) {

            var m = this.defaultMaxListeners;

            if (typeof this._events.maxListeners !== &#x27;undefined&#x27;) {
              m = this._events.maxListeners;
            }

            if (m &gt; 0 &amp;&amp; tree._listeners.length &gt; m) {

              tree._listeners.warned = true;
              console.error(&#x27;(node) warning: possible ud.event memory &#x27; +
                            &#x27;leak detected. %d listeners added. &#x27; +
                            &#x27;Use emitter.setMaxListeners() to increase limit.&#x27;,
                            tree._listeners.length);
              console.trace();
            }
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  };

  
  /**
   * Constructor
   *
   */
  ud.event = function( conf ) {
    this._events = {};
    configure.call(this, conf);
  }

  /**
   * Bestow Event functionality into another object
   *
   * @method bestow
   */
  ud.event.bestow = function bestow( target, config ) {
    
    // Create new instance
    var _event = new ud.event( config );

    // Ensure Target is an Object
    target = target &amp;&amp; &#x27;object&#x27; === typeof target ? target : {};

    for( var key in _event ) {

      if( &#x27;function&#x27; === typeof Object.defineProperty ) {

        Object.defineProperty( target, key, {
          &#x27;value&#x27;: _event[ key ],
          &#x27;enumerable&#x27;: &#x27;function&#x27; === typeof _event[ key ] ? false : true,
          &#x27;writable&#x27;: &#x27;function&#x27; === typeof _event[ key ] ? false : true
        });

      } else {
        target[ key ] = _event[ key ];
      }      

    }

    return target;

  }

  ud.event.prototype.defaults = {
    wildcard: true,
    defaultMaxListeners: 20,
    delimiter: &#x27;.&#x27;
  }

  ud.event.prototype.setMaxListeners = function(n) {
    this._events || init.call(this);
    this._events.maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  };

  ud.event.prototype.event = &#x27;&#x27;;

  ud.event.prototype.once = function once(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  ud.event.prototype.many = function many(event, ttl, fn) {
    var self = this;

    if (typeof fn !== &#x27;function&#x27;) {
      throw new Error(&#x27;many only accepts instances of Function&#x27;);
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    };

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  ud.event.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    // Loop through the *_all* functions and invoke them.
    if (this._all) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];
      for (i = 0, l = this._all.length; i &lt; l; i++) {
        this.event = type;
        this._all[i].apply(this, args);
      }
    }

    // If there is no &#x27;error&#x27; event listener then throw.
    if (type === &#x27;error&#x27;) {

      if (!this._all &amp;&amp; 
        !this._events.error &amp;&amp; 
        !(this._conf.wildcard &amp;&amp; this.listenerTree.error)) {

        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled &#x27;error&#x27; event
        } else {
          throw new Error(&quot;Uncaught, unspecified &#x27;error&#x27; event.&quot;);
        }
        return false;
      }
    }

    var handler;

    if(this._conf.wildcard) {
      handler = [];
      var ns = typeof type === &#x27;string&#x27; ? type.split(this._conf.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    }
    else {
      handler = this._events[type];
    }

    if (typeof handler === &#x27;function&#x27;) {
      this.event = type;
      if (arguments.length === 1) {
        handler.call(this);
      }
      else if (arguments.length &gt; 1)
        switch (arguments.length) {
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      return true;
    }
    else if (handler) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i &lt; l; i++) {
        this.event = type;
        listeners[i].apply(this, args);
      }
      return (listeners.length &gt; 0) || this._all;
    }
    else {
      return this._all;
    }

  };

  ud.event.prototype.on = function(type, listener) {

    if (typeof type === &#x27;function&#x27;) {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== &#x27;function&#x27;) {
      throw new Error(&#x27;on only accepts instances of Function&#x27;);
    }
    this._events || init.call(this);

    if(this._conf.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don&#x27;t need the extra array object.
      this._events[type] = listener;
    } else if(typeof this._events[type] === &#x27;function&#x27;) {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
    else if (isArray(this._events[type])) {
      // If we&#x27;ve already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (!this._events[type].warned) {

        var m = this.defaultMaxListeners;

        if (typeof this._events.maxListeners !== &#x27;undefined&#x27;) {
          m = this._events.maxListeners;
        }

        if (m &gt; 0 &amp;&amp; this._events[type].length &gt; m) {

          this._events[type].warned = true;
          console.error(&#x27;(node) warning: possible ud.event memory &#x27; +
                        &#x27;leak detected. %d listeners added. &#x27; +
                        &#x27;Use emitter.setMaxListeners() to increase limit.&#x27;,
                        this._events[type].length);
          console.trace();
        }
      }
    }
    return this;
  };

  ud.event.prototype.onAny = function(fn) {

    if(!this._all) {
      this._all = [];
    }

    if (typeof fn !== &#x27;function&#x27;) {
      throw new Error(&#x27;onAny only accepts instances of Function&#x27;);
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  ud.event.prototype.addListener = ud.event.prototype.on;

  ud.event.prototype.off = function(type, listener) {
    if (typeof listener !== &#x27;function&#x27;) {
      throw new Error(&#x27;removeListener only takes instances of Function&#x27;);
    }

    var handlers,leafs=[];

    if(this._conf.wildcard) {
      var ns = typeof type === &#x27;string&#x27; ? type.split(this._conf.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i &lt; length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener &amp;&amp; handlers[i].listener === listener) ||
            (handlers[i]._origin &amp;&amp; handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position &lt; 0) {
          return this;
        }

        if(this._conf.wildcard) {
          leaf._listeners.splice(position, 1)
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this._conf.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
      }
      else if (handlers === listener ||
        (handlers.listener &amp;&amp; handlers.listener === listener) ||
        (handlers._origin &amp;&amp; handlers._origin === listener)) {
        if(this._conf.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
    }

    return this;
  };

  ud.event.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn &amp;&amp; this._all &amp;&amp; this._all.length &gt; 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i &lt; l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          return this;
        }
      }
    } else {
      this._all = [];
    }
    return this;
  };

  ud.event.prototype.removeListener = ud.event.prototype.off;

  ud.event.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if(this._conf.wildcard) {
      var ns = typeof type === &#x27;string&#x27; ? type.split(this._conf.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else {
      if (!this._events[type]) return this;
      this._events[type] = null;
    }
    return this;
  };

  ud.event.prototype.listeners = function(type) {
    if(this._conf.wildcard) {
      var handlers = [];
      var ns = typeof type === &#x27;string&#x27; ? type.split(this._conf.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  ud.event.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
